# irene7suq
none
业务用例

接口、边界类、实体类、控制类

包元素、子系统、组织结构、模块 

参与者-系统外，与系统交互的某人或某事

/*区分

功能性需求 

系统可用性

涉众分析

负责提供、使用、删除信息

使用功能

对特定功能感兴趣

在组织中的什么地方使用系统

谁负责支持和维护系统

系统有哪些外部资源 

其他需要与该系统产生交互的系统

参与者

e.g.机票预订系统 

机票购买者-呼叫中心/人工-机票预订系统 

机票购买者-呼叫中心/自动语音预订-机票预订系统

  机票购买者	电话  	呼叫中心子系统	语音/人工
       	网站  	web子系统 	\|   

业务主角

与业务系统产生交互

建立业务模型、查找业务用例，

//玩家处于活跃期时，进行多触点布局与互动 ，拓宽玩家面影响，并找到中后期聚焦与进行自我调整的方向。

面向对象：对象/拥有数据、能力、可以接受命令。。依次向不同的对象发送命令 

继承、封装、多态 

继承，分为单继承、多继承、公有继承，私有继承 

类指向实例，e.g. 徒弟-张三李四王五

重构，保留现有功能，重新梳理软件中的代码结构，确保可读性、结构性、可扩展性，主要目的是提升效率和优化性能··· ··· ··

多线程 

线程是程序执行的最小单位，

多线程程序，获得CPU的几率更高，时间更多，执行速度更快（获得时间片）

一个GUI系统中，操作系统本身的设计是多线程的，其中至少有两个线程，

主线程（绘制界面、响应用户操作）&工作者线程（运算或者完成逻辑，对用户界面和操作不负责响应，将一些结果反馈给主线程，从而展示不同的用户界面和逻辑

e.g. 下载器 （迅雷、旋风、百度）

        后台服务器系统 多线程 ，并发 ，多个人可访问 （并发？均衡负载？）

       app启动 加载新模块，线程做上报，收集1bs信息总结，提开启多个线程做不同的事情，开启多个线程做同一个事情）提升效率

异常捕获

将内存中的数据保存到文件中，向后台发了一次数据请求，调用了一个系统提供的接口来获取一些信息

异常点 写文件的时间较长，这个过程中外存设备被移除了_

异常点  在想后台发送数据请求时使用的端口被别的进程占用

异常点 网络请求的权限被用户关闭掉了

针对性处理，避免影响程序稳定性，做异常捕获 

string id = systeminterface.getID();

调用系统提供的函数获取设备的ID ，如果getID出现异常，被捕获代码裹住，导致的结果是id没有正确赋值，但程序会继续运行

ID未正确赋值可能导致的后果，如果影响比较小，如只是在系统信息界面作为一个条目显示给用户看，如果出现异常，条目是空的。产生的异常未做正确评估和相应处理，程序不挂，但后续的逻辑极度依赖这里的id值，实际相当于把异常产生的地方向后挪了下，后面还是会挂。如不顾逻辑进行异常捕获，程序不挂但应用无法在正常使用。

编不过

 编包

编译器在翻译的过程中发现有单词和语法不符合规范 

空指针

指针，程序运行在内存中，

SDK

安卓平台上开发安卓app，利用安卓SDK提供的API来调用系统能力

，比如要通过安卓SDK调用其中相应的功能实现需求。

API

应用程序编程接口 

API==函数 一个系统的某一项能力 e.g. 某一个地理坐标下天气

在应用开发中，系统暴露的能力是以SDK的形式发行交给开发者的，所以SDK中一般封装了很多API，这些API就对应着系统或平台的能力

【系统专门为一件事或一类事而开发 ，平台是为其他做事的人或设备或系统提供一个基础，可搭载一个或多个系统

API分为公有API（系统以SDK的形式暴露出来，对所有开发者可见，系统授权）

私有API （系统内部使用或仅限于系统自带的一些应用程序使用。不允许应用程序开发者使用的，一般对应用于一些敏感的能力，比如认为此API可能被滥用，造成用户体验下降或此API对其他应用程序可能存在危险）

架构

指一个软件系统的结构。一个软件系统或者系统中的某一模块，都涉及到架构。考虑了一个软件爱你系统的所有设计要素后，梳理清楚模块划分，以及模块之间的关系，所形成结构涉及，需布局各个模块的作用和相互关系

面向对象的程序设计

控件 -任意打开一个app或网页，常见输入框、按钮、单选框、复选框等

组件 - 组合功能的控件 功能更复杂，存在比较复杂的交互 e.g.Tabhost  加入若干个页面，定义了按Tab切换的交互，由最基本的按钮控件和其他控件组合而成

框架 -由很多控件和组件组装在一起，能够在某一领域里完成一系列操作，能够解决某一领域内的问题 e.g. jQuery框架是对原生js的封装，提供更方便快捷的js操作

文本文件和二进制文件

以圆周率为例，π=3.1415926

按照文本文件存储，共9个字符，几个数字分别按照其对应的ASCII码为十进制的63，56,61,64,61,65,71,62,66，每个字符占一个字节，所以共占了9个字节空间

找二进制文件存储，3.1415926是一个浮点数，最终占用4个字节存储

二进制文件（按照数据类型存储）文本文件（按照字符存储）

脚本Script

依据一定格式编写的可执行文件

不同的文本文件&批处理文件

导演了一个序列事件的发生

让一个例行任务效率大幅提升

.bat 

脚本的运行环境：解释器  e.g.汉语按地域划分有多个方言分支，解释器可分多种

JavaScript 浏览器脚本语言 目前也应用于服务端

PHP 

Perl

Shell

Python

Ruby

Lua 

内存泄漏

内存消耗，导致设备运行缓慢、卡顿 

申请内存要释放。不同平台有不同的内存诊断与debug工具，利用工具排查， 进行内存诊断

中间件

middleware 位于应用软件和系统软件之间

电子商务、支付宝、理财通充当人和商家之间的中转和媒介 使交易更有保障和快捷 

.NET 和 Java 中间件 位于操作系统之上，用来更方便地构件应用程序，对操作系统更好的包装，让开发者不需要深入了解操作系统，就可以开发应用程序，降低学习成本，保证效率和稳定性

小功能的封装或某些特性的抽象表述

比如sdk和接口都属于狭义的中间件 一些较好的开源项目 组件等等

写死

e.g. tabhost只能是四个 永远不变 是写死的

某一需求是否会有变化，决定是否要写死 

数据可变、可运营的，这个运营数据应该在服务器端进行配置，再由客户端拉取，然后运行时启用新的配置数据。

这一套过程多出的成本是设计一条协议拉取这项配置或参数。然后应用到程序中，如果已经有这样的运营配置协议，可直接配置

区别 -本地写死，云端可控；客户端产品和程序设计的基本逻辑

本地默认写死一些频道，每次展示，成为打底数据或defult默认数据 保证头部有信息，无网络时也有展示---打底数据主要解决用户体验问题，无网络或初次启动时，给用户隐喻，客户端正在正常运行。

展示打底数据后，发起云端请求，请求云端运营数据，拉取成功后，将新的频道数据覆盖本地数据，如果此次请求失败，则继续展示本地数据，保障用户浏览。

拉取成功前提下，把新的频道数据覆盖本地Defult打底数据，保证客户端下次启动展示上一次成功拉取的频道数据。

编译时 

运行时



变量

盒子里边 各种变量 函数是操作变量的运算逻辑

面向对象的编程语言会定义一些基本的数据类型，组合放在一起，加函数，打包封装在一起，可以成为一个类，

类外使用 public

类内使用 private

定义变量，写函数，运行看变量是否符合预期，不符合预期就把它调到。。。

hash表

存储和查找 的效率决定整个程序的效率 

历遍 存储方式-数组 

哈希冲突 

感知哈希算法，





算法 

0（n^3） 计算时间长，优化需降低算法复杂度

时间和空间 

耗用更多内存，提升速度--空间换时间 

代码中的锁

资源管理问题 

e.g.银行账户

1.款项到达银行 

2.查询账户余额

3.转入款项与余额求和并更新账户余额 

两个转账行为同事操作“账户余额”时，会产生时间重叠。按时间顺序设置“锁” 当某个转账过程获得锁，另一个过程只有等锁被释放后才能继续操作、

系统升级，获得查询锁和更新锁后才能正常执行查询账户和更新账户余额的操作

视频文件

视频文件扩展名 视频封装格式 视频编码格式

封装格式决定视频的规范和组织方法，编码格式决定视频如何压缩和解压缩 

h.264 h.265 编码标准 尽量压缩图片，让整个视频变小 再放进视频容器 比如MP4 



同步 异步 回调

CPU负责执行代码，绘制界面，对用户的点击做出响应

线程  生产线 

同步 

异步 e.g. 游戏登录页面 更新进度最小化，bgm、角色预创建等功能可用

回调 

把自己的信息给别人的过程叫注册，工作人员找到你给你通知信息叫回调 

架构 框架 设计模式

框架约束，应用可以更加规范的构建，确保具体功能不够完善的前提下，整体应用无大问题。各模块间协作流畅

具有复用性，主要针对开发过程中具体的某一类问题

设计模式 

时间戳 MD5 GUID

timestamp-一个事件发生的时间

可能用于消息排序、筛选、信息比较各方面

当某一事件发生时，立刻为它存储一个时间，当应用/程序是一个以timeline时间线为基础的应用，应该设计这个字段

MD5-信息摘要算法-一个文件或字符串生成一个数，这个数是惟一的

GUID-全局唯一标识符 128位数字标识符 

能保证在一个计算机集群中，不会存在两个唯一的值

如产品需要满足用户不登录也要使用基本功能，e.g. 新闻客户端 

建立这个用户的画像，数据模拟出用户的喜好和倾向，需要有这样一个用户身份和标识

栈

stacks

一种数据结构，标识了一个队列，符合先进后出的原则 针对栈，有push 和pop两种操作，表示向栈中加入一个元素，和从栈中退出一个元素，。。

所有操作从栈顶进行，后入栈的元素要先出去，具体结构在程序中的作用，一般用在递归及回溯的算法当中，用来记录整个计算过程中的临时变量，当计算无法再分解，再合并 临时变量的结果。。。

JSON

把对象拆开写成字符串，序列化，

解决“对象”在网络传输的问题

客服端收到JSON字符串后进行解析，按照箱单规则拆来，取出所有字符串，包装成一个对象，这个过程称为反序列化



封装 继承 把用到的所有东西抽象成对象

对象-相当于一块内存，存储着属于本对象的一切数据。也会从“类”那里得到更多方法-方法大多数是来对自身数据做逻辑上的操作

用来存储数据的对象，可以存储任意类型的数据，对象可以有任意个数的成员变量，每个成员变量都有自己的类型，整数、字符串、另一个对象

OpenGL

图形编程

1.CPU在内存里准备好要绘制的东西，然后交给显示器去显示

- 软件绘制，由于CPU本身不擅长做图形相关的运算，效率不高

2.显卡在显存里准备好要绘制的东西，交给显示区显示

- 硬件加速，效率较高 例如游戏，运行时，CPU只是配角，大型游戏也只需要一个入门级的CPU

OpenGL是一组API 这些API可以运行在不同的平台上，可以支持各种语言，

并且能够利用显卡的硬件加速能力，帮我们绘制图形

已实现跨平台（虚拟机，不同的平台都做了兼容，然后给上层调用，都是一样的API）

OpenGL是一个状态机，其中几百个API里，不少是用来设置状态。

每次设置一个状态，都是一次状态切换，直到最终绘制完成。比如画笔红色，在重设成绿色前，绘制的所有图形都是红色。

e.g. 地图导航

选定目的地后，导航路线生成，整条线路里的每条小路当做一个状态，每进入一条小路就切换一次状态。这样经过多次状态切换，最后会到达目的地，对于OpenGL来说，绘制任务完成

引擎

一套能力 /能力组件、集合 

PAC文件

代理服务器 自动代理配置 核心是一个函数

FindProxyForURL(url,host)

输入一个要访问的URL和它的域名 返回一个或多个代理服务器地址 ，也可以返回一个命令，告诉浏览器不使用代理访问该URL



开源

GPL - 不允许作为商业软件发布和销售

LGPL - 相对GPL更宽松，商业软件可以自由发布和销售，同步不必公开源代码，但是不能修改

BSD - 自由使用、修改，开源或专有软件发布 商业公司首选开源证书

MIT - 作者保留版权，无任何限制

WTFPL - 



接口 

硬件场景 e.g. USB接口 一个标准，任何符合标注的USB线都能接入

后台场景 e.g.终端可以在这里调用接口查询当前所有位置的天气 常用于前后端联调 

面向对象的程序设计场景 e.g. 面向对象的程序设计中，对一种能力的抽象，然后分别由不同的开发者来实现【有效隔离调用者和具体实现程序】

可供了解和调用某项能力，定义者和实现者一般不同，调用者不需要关注具体细节，只需要关注接口暴露出的能力。

任何接口都被定义为能力的集合，

1. 定义了一组能力
2. 接口有定义者和实现者
3. 接口定义一般是抽象的，不包括具体的实现

定义一套接口==抽象一种能力集 ，保证调用者只需要知道这个能力并调用，实现者 不需要关心谁调用，只需要做功能

保证了大规模程序开发的可能性，通过接口设计，一个系统被清晰定义成了多种能力的集合 ，每个开发者关注自己对应模块的实现，而调用者负责完成整个程序的业务逻辑

线程池 对象池 连接池

池化技术 - 充分保障系统效率的前提下，充分复用资源 
